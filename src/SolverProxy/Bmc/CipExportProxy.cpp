#include "SolverProxy/Bmc/CipExportProxy.hpp"

#ifdef HAS_BMC_SOLVER_EXPORT_CIP

#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/filter/bzip2.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/filter/lzma.hpp>

#include <chrono>
#include <fstream>
#include <iomanip>
#include <filesystem>

#include "Basic/Logging.hpp"

namespace SolverProxy
{
namespace Bmc
{

CipExportProxy::CipExportProxy(void):
	BmcSolverProxy(BmcSolver::EXPORT_CIP),
	filename(""),
	compression(Compression::None)
{
}

CipExportProxy::~CipExportProxy(void) = default;

void CipExportProxy::Reset(void)
{
	BmcSolverProxy::Reset();
}

static std::string ClauseToString(const Clause<std::pair<BaseLiteral, size_t>>& clause)
{
	std::string clauseText = "(";
	for (auto& [literal, timeframe] : clause)
	{
		if (clauseText != "(")
		{
			clauseText += ", ";
		}

		clauseText += to_string(literal) + ":" + std::to_string(timeframe);
	}
	clauseText += ")";

	return clauseText;
}

BmcResult CipExportProxy::Solve(void)
{
	auto now_tickcount = std::chrono::system_clock::now();
	auto now_timet = std::chrono::system_clock::to_time_t(now_tickcount);
	auto time_tm = std::localtime(&now_timet);

	char timestamp[128u];
	LOG_IF(std::strftime(timestamp, sizeof(timestamp), "%Y-%m-%d_%H-%M-%S", time_tm) == 0u, FATAL)
		<< "The timestamp was not converted into a textural presentaiton";

	std::string filename = GetFilename();
	if (filename == "")
	{
		filename = "./bmc-problem-" + std::string(timestamp) + ".cip";
		for (size_t counter { 0u }; std::filesystem::exists(filename); counter++)
		{
			filename = "./bmc-problem-" + std::string(timestamp) + "_" + std::to_string(counter) + ".cip";
		}
	}

	std::ofstream outfstream { filename };
	LOG_IF(!outfstream.good(), FATAL) << "Could not open file " << filename << " for exporting BMC problem.";

	boost::iostreams::filtering_ostreambuf outfilter;
	switch(compression)
	{
		case Compression::Bzip2:
			outfilter.push(boost::iostreams::bzip2_compressor());
			break;
		case Compression::Gzip:
			outfilter.push(boost::iostreams::gzip_compressor(/*boost::iostreams::gzip_params { 3 }*/));
			break;
		case Compression::Lzma:
			outfilter.push(boost::iostreams::lzma_compressor(/*boost::iostreams::lzma_params { 3 }*/));
			break;
		case Compression::None:
			break;
		default:
			Logging::Panic();
	}
	outfilter.push(outfstream);

	std::ostream out { &outfilter };

	auto clause_to_string = [&](auto& clause, auto& checkFunction) -> std::string {
		std::string result;

		result += "(";
		for (size_t literalIndex = 0u; literalIndex < clause.size(); ++literalIndex)
		{
			auto [literal, timeframe] = clause[literalIndex];
			literal = ConvertProxyToSolver(literal);
			checkFunction(literal, timeframe);

			if (literalIndex != 0u) result += ", ";
			result += "[";
			if (literal.IsNegated()) result += "-";
			result += std::to_string(literal.GetVariable());
			result += ":";
			result += std::to_string(timeframe);
			result += "]";
		}
		result += ")";

		return result;
	};

	out << "--------------------------------------------------------------------------------" << std::endl;
	out << "--  Generated by: FreiTest BMC CIP Export Proxy                               --" << std::endl;
	out << "--  Generation time: " << std::setw(56) << std::left << std::string(timestamp) << " --" << std::endl;
	out << "--  Comments:                                                                 --" << std::endl;
	for (auto comment : comments) out << "--      " << std::setw(69) << std::left << comment << " --" << std::endl;
	out << "--------------------------------------------------------------------------------" << std::endl;
	out << std::endl;

	out << "MAXDEPTH: " << _maximumDepth << std::endl;
	out << "TIMEOUT: " << _solverTimeout << std::endl;
	out << std::endl;

	out << "DECL" << std::endl;
	for (size_t variableIndex = 1u; variableIndex < _variableTypes.size(); ++variableIndex)
	{
		switch (_variableTypes[variableIndex]) {
			case VariableType::Auxiliary:
			case VariableType::Output:
				out << "AUX_VAR " << variableIndex << std::endl;
				break;
			case VariableType::Input:
				out << "INPUT_VAR " << variableIndex << std::endl;
				break;
			case VariableType::Latch:
				out << "LATCH_VAR " << variableIndex << std::endl;
				break;
		}
	}
	out << std::endl;

	out << "INIT" << std::endl;
	for (size_t clauseIndex = 0u; clauseIndex < _initialClauseDB.size(); ++clauseIndex)
	{
		const auto clause = _initialClauseDB[clauseIndex];
		const auto check = [&clause](auto literal, auto timeframe) -> void {
			ASSERT(literal.IsSet()) << "There is a 0 literal in initial clause " << ClauseToString(clause);
			ASSERT(timeframe == 0u) << "There is a literal with timeframe != 0 in initial clause " << ClauseToString(clause);
		};
		out << clause_to_string(clause, check) << std::endl;
	}
	out << std::endl;

	out << "TRANS" << std::endl;
	for (size_t clauseIndex = 0u; clauseIndex < _transitionClauseDB.size(); ++clauseIndex)
	{
		const auto clause = _transitionClauseDB[clauseIndex];
		auto check = [&clause](auto literal, auto timeframe) -> void {
			ASSERT(literal.IsSet()) << "There is a 0 literal in transition clause " << ClauseToString(clause);
			ASSERT(timeframe == 0u || timeframe == 1u) << "There is a literal with timeframe != 0/1 in transition clause " << ClauseToString(clause);
		};
		out << clause_to_string(clause, check) << std::endl;
	}
	out << std::endl;

	out << "TARGET" << std::endl;
	for (size_t clauseIndex = 0u; clauseIndex < _targetClauseDB.size(); ++clauseIndex)
	{
		const auto clause = _targetClauseDB[clauseIndex];
		auto check = [&clause](auto literal, auto timeframe) -> void {
			ASSERT(literal.IsSet()) << "There is a 0 literal in target clause " << ClauseToString(clause);
			ASSERT(timeframe == 0u) << "There is a literal with timeframe != 0 in target clause " << ClauseToString(clause);
		};
		out << clause_to_string(clause, check) << std::endl;
	}
	out << std::endl;

	_lastResult = BmcResult::Timeout;
	_lastDepth = 0u;
	return _lastResult;
}

Value CipExportProxy::GetLiteralValue(BaseLiteral lit) const
{
	if (!lit.IsSet())
	{
		return Value::Invalid;
	}

	return Value::DontCare;
}

std::string CipExportProxy::GetFilename(void) const
{
	return filename;
}

void CipExportProxy::SetFilename(std::string filename)
{
	this->filename = filename;
}

std::vector<std::string> CipExportProxy::GetComments(void) const
{
	return comments;
}

void CipExportProxy::SetComments(std::vector<std::string> comments)
{
	this->comments = comments;
}

void CipExportProxy::SetCompression(CipExportProxy::Compression compression)
{
	this->compression = compression;
}

CipExportProxy::Compression CipExportProxy::GetCompression(void) const
{
	return compression;
}

};
};

#endif
